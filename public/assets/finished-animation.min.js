function createWrapper(target) {

    const wrapper = document.createElement('div');
    const style = window.getComputedStyle(target);
    wrapper.style.position = style.getPropertyValue('position');
    wrapper.style.left = style.getPropertyValue('left');
    wrapper.style.top = style.getPropertyValue('top');
    wrapper.style.width = style.getPropertyValue('width');
    wrapper.style.height = style.getPropertyValue('height');

    target.parentNode.insertBefore(wrapper, target);
    target.parentNode.removeChild(target);
    wrapper.appendChild(target);

    return wrapper;
}


function createInner(target) {
    const inner = document.createElement('div');
    const style = window.getComputedStyle(target);
    inner.style.display = style.getPropertyValue('display');
    inner.style.alignItems = style.getPropertyValue('align-items');
    inner.style.justifyContent = style.getPropertyValue('justify-content');
    inner.style.position = 'absolute';
    inner.style.width = '100%';
    inner.style.height = '100%';
    inner.style.left = '0px';
    inner.style.top = '0px';

    target.appendChild(inner);
    return inner;
}

function cloneElement(target, isChild = true) {
    const clone = target.cloneNode(true);
    clone.style.position = 'absolute';
    clone.style.width = '100%';
    clone.style.height = '100%';
    clone.style.left = '0px';
    clone.style.top = '0px';

    if (isChild) target.appendChild(clone);
    return clone;
}

function splitText(target) {
    // text가 아닌 다른 요소가 있을경우 경고 필요
    target.innerHTML = target.textContent.replace(/\S/g, "<span>$&</span>");
    return target.querySelectorAll('span');
}

//x는 0~1의 값
function linearFromTo(x, from = 0, to = 100) {
    return (x * (to - from)) + from;
}

function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min; //최댓값은 제외, 최솟값은 포함
}

function parseColor(input) {
    let m;
    m = input.match(/^#([0-9a-f]{3})$/i);
    if (m) {
        // in three-character format, each value is multiplied by 0x11 to give an
        // even scale from 0x00 to 0xff
        return [
            parseInt(m[1].charAt(0), 16) * 0x11,
            parseInt(m[1].charAt(1), 16) * 0x11,
            parseInt(m[1].charAt(2), 16) * 0x11
        ];
    }
    m = input.match(/^#([0-9a-f]{6})$/i);
    if (m) {
        return [
            parseInt(m[1].substr(0, 2), 16),
            parseInt(m[1].substr(2, 2), 16),
            parseInt(m[1].substr(4, 2), 16)
        ];
    }
    m = input.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
    if (m) {
        return [Number(m[1]), Number(m[2]), Number(m[3])];
    }
    return ({
        "red": [255, 0, 0],
        "yellow": [255, 255, 0],
        // ... and so on. Yes, you have to define ALL the colour codes.
    })[input];

}

function clickEvent(selector, animation) {
    const target = document.querySelector(selector);
    target.addEventListener('click', (e) => { animation.play(); });
}

function hoverEvent(selector, animation) {
    const target = document.querySelector(selector);
    if (animation.enter) {
        target.addEventListener('mouseenter', (e) => { animation.enter.play({ e: e }); });
        target.addEventListener('mousemove', (e) => animation.move.play(e));
        target.addEventListener('mouseleave', (e) => animation.leave.play({ e: e }));
    } else {
        target.addEventListener('mouseenter', (e) => animation.play({ e: e }));
        target.addEventListener('mouseleave', (e) => animation.reverse({ e: e }));
    }
}

function viewEvent(selector, animation) {
    const target = document.querySelector(selector);
    const winH = window.innerHeight;

    const view = () => {
        requestAnimationFrame(() => {
            const posFromTop = target.getBoundingClientRect().top;
            if (winH > posFromTop + 200) {
                animation.play();
            }
        })
    }
    view();
    window.addEventListener('scroll', () => {
        view();
    })
}

function scrollEvent(selector, animation, start, end) {
    animation.time(0);
    window.addEventListener('scroll', (e) => {
        requestAnimationFrame(() => {
            let ratio = (window.scrollY - start) / (end - start) * 100
            if (ratio > 100) ratio = 100;
            if (ratio < 0) ratio = 0;

            animation.time(ratio);
        });
    })


}


const easingFunction = {
    linear: (x) => {
        return x;
    },

    easeInSine: (x) => {
        return 1 - Math.cos((x * Math.PI) / 2);
    },
    easeOutSine: (x) => {
        return Math.sin((x * Math.PI) / 2);
    },
    easeInOutSine: (x) => {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    },
    easeInQuad: (x) => {
        return x * x;
    },

    easeOutQuad: (x) => {
        return 1 - (1 - x) * (1 - x);
    },
    easeInOutQuad: (x) => {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    },

    easeInCubic: (x) => {
        return x * x * x;
    },
    easeOutCubic: (x) => {
        return 1 - Math.pow(1 - x, 3);
    },
    easeInOutCubic: (x) => {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    },
    easeInQuart: (x) => {
        return x * x * x * x;
    },
    easeOutQuart: (x) => {
        return 1 - Math.pow(1 - x, 4);
    },
    easeInOutQuart: (x) => {
        return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;
    },
    easeInQuint: (x) => {
        return x * x * x * x * x;
    },
    easeOutQuint: (x) => {
        return 1 - Math.pow(1 - x, 5);
    },
    easeInOutQuint: (x) => {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    },
    easeInExpo: (x) => {
        return x === 0 ? 0 : Math.pow(2, 10 * x - 10);
    },
    easeOutExpo: (x) => {
        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
    },
    easeInOutExpo: (x) => {
        return x === 0
            ? 0
            : x === 1
                ? 1
                : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2
                    : (2 - Math.pow(2, -20 * x + 10)) / 2;
    },
    easeInCirc: (x) => {
        return 1 - Math.sqrt(1 - Math.pow(x, 2));
    },
    easeOutCirc: (x) => {
        return Math.sqrt(1 - Math.pow(x - 1, 2));
    },
    easeInOutCirc: (x) => {
        return x < 0.5
            ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2
            : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;
    },
    easeInBack: (x) => {
        const c1 = 1.70158;
        const c3 = c1 + 1;

        return c3 * x * x * x - c1 * x * x;
    },
    easeOutBack: (x) => {
        const c1 = 1.70158;
        const c3 = c1 + 1;

        return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
    },
    easeInOutBack: (x) => {
        const c1 = 1.70158;
        const c2 = c1 * 1.525;

        return x < 0.5
            ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
            : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
    },
    easeInElastic: (x) => {
        const c4 = (2 * Math.PI) / 3;

        return x === 0
            ? 0
            : x === 1
                ? 1
                : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);
    },
    easeOutElastic: (x) => {
        const c4 = (2 * Math.PI) / 3;

        return x === 0
            ? 0
            : x === 1
                ? 1
                : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
    },
    easeInOutElastic: (x) => {
        const c5 = (2 * Math.PI) / 4.5;

        return x === 0
            ? 0
            : x === 1
                ? 1
                : x < 0.5
                    ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2
                    : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1;
    },
    easeInBounce: (x) => {
        return 1 - easingFunction.easeOutBounce(1 - x);
    },
    easeOutBounce: (x) => {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (x < 1 / d1) {
            return n1 * x * x;
        } else if (x < 2 / d1) {
            return n1 * (x -= 1.5 / d1) * x + 0.75;
        } else if (x < 2.5 / d1) {
            return n1 * (x -= 2.25 / d1) * x + 0.9375;
        } else {
            return n1 * (x -= 2.625 / d1) * x + 0.984375;
        }
    },
    easeInOutBounce: (x) => {
        return x < 0.5
            ? (1 - easingFunction.easeOutBounce(1 - 2 * x)) / 2
            : (1 + easingFunction.easeOutBounce(2 * x - 1)) / 2;
    },


}


class FinAnimaCore {
    constructor(params = {}) {
        this.frameSize = 0;

        this.startFrame = 0;
        this.currentFrame = 0;
        this.state = 0;

        this.FinAnimaList = [];

        this.repeat = params.repeat ? true : false;
    }

    time(frame) {
        requestAnimationFrame(() => {
            const currentFrame = frame / 100 * this.frameSize;
        this.FinAnimaList.forEach(finAnima => {
                if (finAnima.firstFrame <= currentFrame &&
                    finAnima.lastFrame >= currentFrame &&
                    finAnima.state !== 1) {
                    
                    finAnima.time(currentFrame - finAnima.firstFrame);
                }else if(finAnima.firstFrame-100 <= currentFrame &&
                    currentFrame <= finAnima.firstFrame ){
                    finAnima.time(0);
                }else if(finAnima.lastFrame <= currentFrame &&
                    currentFrame <= finAnima.lastFrame +100){
                    finAnima.time(finAnima.lastFrame +100);
                }
            })
        });
    }

    setRepeat(bool) { this.repeat = bool }
    addFinAnima(finAnima) {
        finAnima.setFrame(this.frameSize);
        this.FinAnimaList.push(finAnima);
        if (this.FinAnimaList.length === 1) {
            this.frameSize += finAnima.frameSize;
            return;
        }

        let max = 0;
        this.FinAnimaList.forEach(finAnima => {
            if (max < finAnima.lastFrame) max = finAnima.lastFrame;
        });
        this.frameSize = max;
    }

    play(params) {
        if (this.state === 1) return;
        if (this.state === -1) { this.stop(); }
        let start;
        if (this.repeat) this.startFrame = 0;

        const step = (timestamp) => {
            if (this.state === 0) {
                start = timestamp;
                this.state = 1
            };

            timestamp += this.startFrame;
            const frame = timestamp - start;
            this.currentFrame = frame;

            this.FinAnimaList.forEach(finAnima => {
                if (finAnima.firstFrame <= frame &&
                    finAnima.lastFrame >= frame &&
                    finAnima.state !== 1) {
                    finAnima.play(frame - finAnima.firstFrame, params);
                }
            })

            if (frame < this.frameSize + 50) this.animationRef = requestAnimationFrame(step);
            else { this.stop(); }

        }

        this.animationRef = requestAnimationFrame(step);
    }
    stop() {
        if (this.state === 0) return;
        this.state = 0;
        this.startFrame = this.currentFrame;
        cancelAnimationFrame(this.animationRef);
        this.FinAnimaList.forEach(finAnima => {
            finAnima.stop();
        });
    }

    reverse(params) {
        if (this.state === -1) return;
        if (this.state === 1) { this.stop(); }

        let start;
        const step = (timestamp) => {
            if (this.state !== -1) {
                start = timestamp;
                this.state = -1;
            };

            const frame = this.startFrame - (timestamp - start);
            this.currentFrame = frame;
            this.FinAnimaList.forEach(finAnima => {
                if (finAnima.firstFrame <= frame &&
                    finAnima.lastFrame >= frame &&
                    finAnima.state !== -1) {
                    finAnima.reverse(frame - finAnima.firstFrame, params);
                }
            })
            if (frame > -50) this.animationRef = requestAnimationFrame(step);
            else this.stop();
        }
        this.animationRef = requestAnimationFrame(step);
    }
}


class FinAnima {
    constructor(props) {
        if (!props.duration) console.error("duration is null.");

        this.frameSize = this.checkTiming(props.duration);

        this.timing = this.checkTiming(props.timing);

        this.easingFunction = easingFunction[props.easingFunction] || easingFunction.linear;

        this.firstFrame = 0;
        this.lastFrame = 0;

        this.startFrame = 0;
        this.currentFrame = 0;

        // -1: 되감기, 0: 정지, 1 재생
        this.state = 0;
        this.initFunc = props.initFunc;
        this.func = props.func;
        this.animationRef = null;

        //this.play();
    }

    checkTiming(timing) {
        if (!timing) return 0;

        if (typeof (timing) === "number")
            return timing *= 1000;
        else {
            let result = timing.match(/[0-9]+%/g);
            if (result) return result[0];
        }

    }

    setFrame(frame) {

        if (typeof (this.timing) === "string" && this.timing.match(/[0-9]+%/g)) {
            this.firstFrame = frame * Number(this.timing.slice(0, -1));
        } else {
            this.firstFrame = frame + this.timing;
        }

        if (this.firstFrame < 0) this.firstFrame = 0;

        if (typeof (this.frameSize) === "string" && this.frameSize.match(/[0-9]+%/g)) {
            this.frameSize = frame * Number(this.frameSize.slice(0, -1) * 0.01);
        }
        this.lastFrame = this.firstFrame + this.frameSize;



    }

    time(frame) {
        const originProgress = frame / this.frameSize;
        const progress = originProgress > 1 ? 1 :
            (originProgress < 0 ? 0 : originProgress)
        this.func(this.easingFunction(progress));
    }

    play(startFrame, params) {

        if (this.state === -1) {
            this.stop();
        }
        if (this.initFunc) this.initFunc(params.e);
        let start;
        const step = (timestamp) => {

            if (this.state === 0) {
                start = timestamp;
                this.state = 1
            };

            timestamp += startFrame;
            const frame = timestamp - start;
            const originProgress = frame / this.frameSize;
            const progress = originProgress > 1 ? 1 :
                (originProgress < 0 ? 0 : originProgress)

            this.func(this.easingFunction(progress));
            if (originProgress < 1) this.animationRef = requestAnimationFrame(step);
            else {
                this.func(1);
                this.stop();
            }

        }

        this.animationRef = requestAnimationFrame(step);
    }

    stop() {
        this.state = 0;
        cancelAnimationFrame(this.animationRef);
    }

    reverse(startFrame, params) {
        if (this.state === 1) {
            this.stop();
        }
        if (this.initFunc) this.initFunc(params.e);
        let start;
        const step = (timestamp) => {

            if (this.state !== -1) {
                start = timestamp;
                this.state = -1
            };

            const frame = startFrame - (timestamp - start);
            const originProgress = frame / this.frameSize;
            const progress = originProgress > 1 ? 1 :
                (originProgress < 0 ? 0 : originProgress)

            this.func(this.easingFunction(progress));

            if (originProgress > 0) this.animationRef = requestAnimationFrame(step);
            else {
                this.func(0);
                this.stop();
            }
        }

        this.animationRef = requestAnimationFrame(step);

    }
}



class Animation {
    constructor(params) {
        this.name = params.name;
        this.params = params;
        this.target = typeof (this.params.target) === "string" ?
            document.querySelector(this.params.target) :
            this.params.target;

        this.animationList = null;
        this.animation = {};
        this.event = params.event; // hover, click, view, scroll

    }

    ready() {
        const finAnima = this.animationList[this.name](this.params);
        switch (this.event) {
            case 'hover':

                this.animation.enter = finAnima.enter ?? finAnima;
                this.animation.leave = finAnima.leave ?? 'reverse-enter';
                this.animation.move = finAnima.move;
                break;
            case 'view':
                finAnima.noRepeat();
                this.animation.view = finAnima;
                break;
            case 'click':
                this.animation.click = finAnima;
                break;

            case 'position':
                this.animation.position = finAnima;
                break;

            case 'mouse':
                this.animation.mouse = finAnima;
                break;

            default:
                break;
        }

        if (window.getComputedStyle(this.target).display === 'inline')
            this.target.style.display = 'inline-block';

    }

    setAnimation(event, animation) {
        this.animation[event] = animation;
    }

    play() {
        if (this.animation.enter)
            this.target.addEventListener('mouseenter', (e) => this.animation.enter.play({ e: e }));

        if (this.animation.move)
            this.target.addEventListener('mousemove', (e) => this.animation.move.play(e));

        if (this.animation.leave) {
            if (this.animation.leave === 'reverse-enter')
                this.target.addEventListener('mouseleave', (e) => this.animation.enter.reverse({ e: e }));
            else
                this.target.addEventListener('mouseleave', (e) => this.animation.leave.play({ e: e }));
        }
        if (this.animation.view) {
            const winH = window.innerHeight;
            window.addEventListener('scroll', (e) => {
                requestAnimationFrame(() => {
                    const posFromTop = this.target.getBoundingClientRect().top;
                    if (winH > posFromTop + 200) {
                        this.animation.view.play();
                    }
                })
            })
        }

    }
}

class CommonAnimation extends Animation {

    constructor(params) {
        super(params);
        this.animationList = commonAnimationList;

        this.ready();
        this.play();
    }
}

class TextAnimation extends Animation {
    constructor(params) {
        super(params);
        this.animationList = textAnimationList;

        this.ready();
        this.play();
    }
}

class ImageAnimation extends Animation {
    constructor(params) {
        super(params);
        this.animationList = imageAnimation;

        this.ready();
        this.play();
    }
}

const typing = (anima) => {
    anima = {
        duration: 0.3,
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    /******init*******/
    const target = document.querySelector(anima.target)
    const spanArray = splitText(target);
    spanArray.forEach(span => { span.style.display = 'none' })

    /******play*******/
    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                span.style.display = "inline";
            },
            duration: anima.duration,
        })
        finAnimaCore.addFinAnima(finAnima)
    })


    return finAnimaCore;
}

const neonText = (anima) => {
    anima = {
        bright: 20,
        duration: 0.5,
        easingFunction: 'easeOutQuart',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    const color = window.getComputedStyle(target, null).getPropertyValue('color');
    const neonDom = cloneElement(target);
    neonDom.style.opacity = 0;
    neonDom.style.textShadow = `0px 0px ${anima.bright}px ${color}`;

    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    const finAnima = new FinAnima({
        func: (progress) => {
            neonDom.style.opacity = progress;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima);




    return finAnimaCore;

}



const cloudy = (anima) => {
    anima = {
        maxLetterSpacing: 30,
        blur: 60,
        duration: 3,
        easingFunction: 'easeOutSine',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    const color = window.getComputedStyle(target, null).getPropertyValue('color');
    target.style.letterSpacing = `${anima.maxLetterSpacing}px`;
    target.style.textShadow = `0px 0px ${anima.blur}px ${color}`;
    target.style.color = "transparent"


    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    const finAnima = new FinAnima({
        func: (progress) => {
            const curLetterSpacing = anima.maxLetterSpacing - (anima.maxLetterSpacing * progress);
            const curBlur = anima.blur - (anima.blur * progress);
            target.style.letterSpacing = `${curLetterSpacing}px`;
            target.style.textShadow = `0px 0px ${curBlur}px ${color}`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima);



    return finAnimaCore;
}

const jump = (anima) => {
    anima = {
        height: 50,
        duration: 1,
        timing: -0.8,
        easingFunction: 'easeOutQuart',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    const spanArray = splitText(target);
    spanArray.forEach((span) => {
        span.style.display = "inline-block";
    })

    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                if (progress <= 0.5) {
                    span.style.transform = `translateY(-${(anima.height * (progress * 2))}px)`;
                } else {
                    span.style.transform = `translateY(-${anima.height * (progress * -2 + 2)}px)`;
                }
            },
            duration: anima.duration,
            timing: anima.timing,
            easingFunction: anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })




    return finAnimaCore;
}

const appearFromBottom = (anima) => {
    anima = {
        duration: 0.5,
        timing: -0.4,
        easingFunction: 'easeOutQuart',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    const color = window.getComputedStyle(target, null).getPropertyValue('color');
    target.style.overflow = "hidden";
    const spanArray = splitText(target);
    spanArray.forEach(span => {
        span.style.display = 'inline-block';
        span.style.transform = 'translateY(100%)';
        span.style.opacity = 0;
    })

    const line = document.createElement('div');
    target.appendChild(line);
    line.style.position = "relative";
    line.style.width = "100%";
    line.style.height = "5px";
    line.style.backgroundColor = color;
    line.style.transform = 'translateX(-101%)';

    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                if (progress > 1) progress = 1;
                if (progress < 0) progress = 0;

                span.style.transform = `translateY(${100 - (progress * 100)}%)`;
                span.style.opacity = progress;
            },
            duration: anima.duration,
            timing: anima.timing,
            easingFunction: anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })

    const lineAnima = new FinAnima({
        func: (progress) => {
            if (progress > 1) progress = 1;
            if (progress < 0) progress = 0;

            if (progress === 0) line.style.transform = `translateX(-101%)`;
            else line.style.transform = `translateX(-${100 - (progress * 100)}%)`;

        },
        duration: '100%',
        timing: '0%',
        easingFunction: 'easeInOutQuad',
    })
    finAnimaCore.addFinAnima(lineAnima);


    return finAnimaCore;;
}

const backColorCover = (anima) => {
    anima = {
        duration: 1.5,
        color: '#333',
        backgroundColor: '#fff',
        easingFunction: 'easeInOutCubic',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    target.style.overflow = "hidden";

    const clone = cloneElement(target);
    clone.style.position = 'relative';
    clone.style.transform = 'translate(-100%, -100%)';
    clone.style.backgroundColor = anima.backgroundColor;

    const cloneText = document.createElement('div');
    cloneText.innerText = clone.innerText;
    clone.innerText = '';
    cloneText.style.transform = 'translateX(100%)';
    cloneText.style.color = anima.color;
    clone.appendChild(cloneText);

    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    const finAnima = new FinAnima({
        func: (progress) => {
            if (progress > 1) progress = 1;
            if (progress < 0) progress = 0;

            clone.style.transform = `translate(-${100 - (progress * 100)}%, -100%)`;
            cloneText.style.transform = `translateX(${100 - (progress * 100)}%)`;
        },
        duration: anima.duration,
        timing: anima.timing,
        easingFunction: anima.easingFunction,
    });
    finAnimaCore.addFinAnima(finAnima)



    return finAnimaCore;;
}

const appearRotate = (anima) => {
    anima = {
        duration: 0.5,
        timing: -0.2,
        easingFunction: 'easeOutSine',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    const spanArray = splitText(target);
    spanArray.forEach(span => {
        span.style.opacity = 0;
        span.style.display = 'inline-block';
        span.style.transform = 'rotateY(-180deg)';
    })

    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                if (progress > 1) progress = 1;
                if (progress < 0) progress = 0;

                if (progress < 0.5) span.style.opacity = progress * 2;
                else span.style.opacity = 1;

                span.style.transform = `rotateY(-${180 - (progress * 180)}deg)`;
            },
            duration: anima.duration,
            timing: anima.timing,
            easingFunction: anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })



    return finAnimaCore;;
}

const fillText = (anima) => {
    anima = {
        duration: 1,
        easingFunction: 'easeInOutSine',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    const color = window.getComputedStyle(target, null).getPropertyValue('color');
    target.style.overflow = "hidden";
    target.style.color = "transparent";
    target.style.position = "relative";
    target.style.webkitTextStroke = `0.5px ${color}`;


    const inner = createInner(target);
    inner.style.transform = 'translateX(-100%)';
    inner.style.overflow = "hidden";

    const cloneText = document.createElement('div');
    cloneText.innerText = target.innerText;
    cloneText.style.transform = 'translateX(100%)';
    cloneText.style.width = '100%';
    cloneText.style.color = color;
    inner.appendChild(cloneText);

    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    const finAnima = new FinAnima({
        func: (progress) => {
            if (progress > 1) progress = 1;
            if (progress < 0) progress = 0;

            inner.style.transform = `translateX(-${100 - (progress * 100)}%)`;
            cloneText.style.transform = `translateX(${100 - (progress * 100)}%)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    });
    finAnimaCore.addFinAnima(finAnima);


    return finAnimaCore;
}

const typing2 = (anima) => {
    anima = {
        duration: 1,
        easingFunction: 'easeInOutSine',
        ...anima,
    }
    /******init*******/
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target)
    const spanArray = splitText(target);
    spanArray.forEach(span => { span.style.opacity = 0 })

    /******play*******/
    const finAnimaCore = new FinAnimaCore({
        repeat: false
    });
    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                span.style.opacity = progress;
            },
            duration: anima.duration,
            timing: -(anima.duration - 0.1),
        })
        finAnimaCore.addFinAnima(finAnima)
    })


    return finAnimaCore;
}

const converText = (anima) => {
    anima = {
        duration: 0.5,
        timing:0.05,
        easingFunction: 'easeInOutSine',
        ...anima,
    }
    /******init*******/
    if (!anima.target) { console.error('target is undefined'); return; }
    if (!anima.afterText) { console.error('afterText is undefined'); return; }
    const target = document.querySelector(anima.target)
    const spanArray = splitText(target);
    const afterText = cloneElement(target);


    target.style.position = 'relative';
    target.style.overflow = 'hidden';
    

    
    afterText.innerText = anima.afterText;
    afterText.style.position = 'absolute'
    afterText.style.top = '0px';
    afterText.style.left = '0px';
    const afterTextArray = splitText(afterText);
    afterTextArray.forEach(span => { span.style.opacity = 0 })

    //afterText.style.transform = 'translateY(100%)';
    

    /******play*******/
    const finAnimaCore = new FinAnimaCore();

    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                span.style.opacity = 1 - progress;
            },
            duration: anima.duration,
            timing: -(anima.duration - anima.timing),
        })
        finAnimaCore.addFinAnima(finAnima)
    })

    afterTextArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                span.style.opacity = progress;
            },
            duration: anima.duration,
            timing: -(anima.duration - anima.timing),
        })
        finAnimaCore.addFinAnima(finAnima)
    })


    return finAnimaCore;
}


const converText2 = (anima) => {
    anima = {
        duration: 1,
        timing:0.02,
        easingFunction: 'easeOutElastic',
        ...anima,
    }
    /******init*******/
    if (!anima.target) { console.error('target is undefined'); return; }
    if (!anima.afterText) { console.error('afterText is undefined'); return; }
    const target = document.querySelector(anima.target)
    const spanArray = splitText(target);
    const afterText = cloneElement(target);

    spanArray.forEach(span => { 
        span.style.display = 'inline-block';
    })
    target.style.position = 'relative';
    target.style.overflow = 'hidden';
    

    
    afterText.innerText = anima.afterText;
    afterText.style.position = 'absolute'
    afterText.style.top = '0px';
    afterText.style.left = '0px';
    const afterTextArray = splitText(afterText);
    afterTextArray.forEach(span => { 
        span.style.display = 'inline-block';
        span.style.transform = 'translateY(100%)';
    })

    
    

    /******play*******/
    const finAnimaCore = new FinAnimaCore();

    spanArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                span.style.transform = `translateY(-${progress*100}%)`;
            },
            duration: anima.duration,
            timing: -(anima.duration - anima.timing),
            easingFunction:anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })

    afterTextArray.forEach((span) => {
        const finAnima = new FinAnima({
            func: (progress) => {
                span.style.transform = `translateY(${100 - (progress*100)}%)`;
            },
            duration: anima.duration,
            timing: -(anima.duration - anima.timing),
            easingFunction:anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })


    return finAnimaCore;
}
const innerSlide1 = (anima) => {
    anima = {
        duration: 0.5,
        backgroundColor: '#fff',
        color: '#333',
        easingFunction: 'easeInOutQuint',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');

    /******init*******/
    const target = document.querySelector(anima.target);
    target.style.overflow = 'hidden';
    const target__style = window.getComputedStyle(target,null);
    if (target__style.getPropertyValue('position') === 'static')
        target.style.position = "relative";

    const inner = cloneElement(target);
    inner.style.background = anima.backgroundColor;
    inner.style.transform = 'translateX(-101%)';
    inner.style.overflow = "hidden";
    inner.style.color = anima.color;

    const text = inner.innerText;
    inner.innerText = '';
    const innerText = document.createElement('div');
    inner.appendChild(innerText);
    innerText.innerText = text;
    innerText.style.position = 'absolute';
    innerText.style.display = 'flex';
    innerText.style.justifyContent = 'center';
    innerText.style.alignItems = 'center';
    innerText.style.width = '100%';
    innerText.style.height = '100%';
    innerText.style.color = anima.color;
    innerText.style.transform = 'translateX(100%)';
    innerText.style.whiteSpace = 'nowrap';


    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima = new FinAnima({
        func: (progress) => {
            const transX = linearFromTo(progress, 100, 0);
            inner.style.transform = `translateX(${-transX}%)`;
            innerText.style.transform = `translateX(${transX}%)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)
    return finAnimaCore;
}


const circleOverlay1 = (anima) => {
    anima = {
        duration: 0.6,
        backgroundColor: '#fff',
        color: '#333',
        easingFunction: 'easeInOutCubic',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');

    /******init*******/
    const target = document.querySelector(anima.target);
    const target__style = window.getComputedStyle(target,null);
    const originColor = target__style.getPropertyValue('color');
    if (target__style.getPropertyValue('position') === 'static')
        target.style.position = "relative";
    const text = target.innerText;
    target.style.overflow = "hidden";
    target.innerText = '';

    const inner = cloneElement(target);
    inner.style.background = anima.backgroundColor;
    inner.style.transform = 'translateY(50%) scale(0, 0)';
    inner.style.overflow = "hidden";
    inner.style.borderRadius = '100%';
    
    const targetText = document.createElement('span');
    targetText.innerText = text;
    targetText.style.display = 'inline-block';
    target.appendChild(targetText);

    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima1 = new FinAnima({
        initFunc: () => {targetText.style.color = originColor;},
        func: (progress) => {
            
            const opacity = linearFromTo(progress, 1, -1);
            targetText.style.opacity = opacity;
            targetText.style.transform = `translateY(-${progress*100}%)`;
        },
        duration: 0.5 * anima.duration,
        easingFunction: anima.easingFunction,
    })
    const finAnima2 = new FinAnima({
        func: (progress) => {
            inner.style.transform = `translateY(50%) scale(${progress*3}, ${progress*3})`;
        },
        duration: 0.8 * anima.duration,
        timing: -0.5 * anima.duration,
        easingFunction: anima.easingFunction,
    })
    const finAnima3 = new FinAnima({
        initFunc: () => {targetText.style.color = anima.color;},
        func: (progress) => {
            const y = linearFromTo(progress, 100, 0);
            targetText.style.opacity = progress;
            targetText.style.transform = `translateY(${y}%)`;
        },
        duration: anima.duration,
        timing: -0.5 * anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima1)
    finAnimaCore.addFinAnima(finAnima2)
    finAnimaCore.addFinAnima(finAnima3)
    return finAnimaCore;
};

const circleOverlay2 = (anima) => {
    anima = {
        duration: 0.6,
        backgroundColor: '#fff',
        color: '#333',
        easingFunction: 'easeInOutCubic',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');

    /******init*******/
    const target = document.querySelector(anima.target);
    const target__style = window.getComputedStyle(target,null);
    if (target__style.getPropertyValue('position') === 'static')
        target.style.position = "relative";
        const text = target.innerText;

        target.style.overflow = "hidden";
        target.innerText = '';
    const originColor = target__style.getPropertyValue('color');
    const color = parseColor(originColor);
    const animaColor = parseColor(anima.color);

    const width = Number(target__style.getPropertyValue('width').match(/[0-9]+/)[0]);
    const height =  Number(target__style.getPropertyValue('height').match(/[0-9]+/)[0]);
    const long = width > height ? width : height;
    const small = width > height ? height : width;
    const ratio = long*1.5 / small;
  
    const inner = cloneElement(target);
    inner.style.background = anima.backgroundColor;
    inner.style.transform = 'scale(0, 0)';
    inner.style.overflow = "hidden";
    inner.style.left = 'auto';
    inner.style.height = 'auto';
    inner.style.width = `${small}px`;
    inner.style.height = `${small}px`;
    inner.style.borderRadius = '100%';
    
    const targetText = document.createElement('span');
    targetText.innerText = text;
    targetText.style.display = 'inline-block';
    targetText.style.zIndex = 1;
    target.appendChild(targetText);


    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima1 = new FinAnima({
        func: (progress) => {
            const r = linearFromTo(progress, color[0], animaColor[0]);
            const g = linearFromTo(progress, color[1], animaColor[1]);
            const b = linearFromTo(progress, color[2], animaColor[2]);
            targetText.style.color = `rgb(${r}, ${g}, ${b})`;
        },
        duration: 0.8 * anima.duration,
        easingFunction: anima.easingFunction,
    })
    const finAnima2 = new FinAnima({
        func: (progress) => {

            inner.style.transform = ` scale(${progress * ratio}, ${progress * ratio})`;
        },
        duration: 0.8 * anima.duration,
        timing: '0%',
        easingFunction: anima.easingFunction,
    })

    finAnimaCore.addFinAnima(finAnima1)
    finAnimaCore.addFinAnima(finAnima2)
    return finAnimaCore;
};
const neon = (anima) => {
    anima = {
        duration: 0.6,
        backgroundColor: '#fff',
        color: '#333',
        easingFunction: 'easeInExpo',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');

    /******init*******/
    const target = document.querySelector(anima.target);
    const target__style = window.getComputedStyle(target,null);
    if (target__style.getPropertyValue('position') === 'static')
    target.style.position = "relative";
    const text = target.innerText;

    target.innerText = '';

    const borderRadius = window.getComputedStyle(target, null).getPropertyValue('border-radius');
    const color = parseColor(window.getComputedStyle(target, null).getPropertyValue('color'));
    const animaColor = parseColor(anima.color);

    const inner = createInner(target);
    inner.style.backgroundColor = anima.backgroundColor;
    inner.style.boxShadow = `0px 0px 10px 5px ${anima.backgroundColor}`;
    inner.style.borderRadius = borderRadius;
    inner.style.opacity = 0;

    const targetText = document.createElement('span');
    targetText.innerText = text;
    targetText.style.zIndex = 1;
    target.appendChild(targetText);

    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima1 = new FinAnima({
        func: (progress) => {
            const r = linearFromTo(progress, color[0], animaColor[0]);
            const g = linearFromTo(progress, color[1], animaColor[1]);
            const b = linearFromTo(progress, color[2], animaColor[2]);
            targetText.style.color = `rgb(${r}, ${g}, ${b})`;
        },
        duration: 0.8 * anima.duration,
        easingFunction: anima.easingFunction,
    })
    const finAnima2 = new FinAnima({
        func: (progress) => {
            inner.style.opacity = progress;
        },
        duration: 0.8 * anima.duration,
        timing: '0%',
        easingFunction: anima.easingFunction,
    })


    finAnimaCore.addFinAnima(finAnima1)
    finAnimaCore.addFinAnima(finAnima2)

    return finAnimaCore;
}

    

const followingCursor = (anima) => {
    anima = {
        a:0.1,
        w:30,
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    if (anima.a>1) {anima.a=1;}
    const target = document.querySelector(anima.target);
    const rect = target.getBoundingClientRect();

    const Attribute = {
        x:0,
        y:0,
        finX:0,
        finY:0,
        onMouse:false,
        translateRef: null,

        translate: () => {
            const step = () => {
                Attribute.x = Attribute.x + (Attribute.finX - Attribute.x) * anima.a;
                Attribute.y = Attribute.y + (Attribute.finY - Attribute.y) * anima.a;
                target.style.transform = `translate(${Attribute.x*anima.w}%, ${Attribute.y*anima.w}%)`;
                Attribute.translateRef = requestAnimationFrame(step);
            }
            Attribute.translateRef = requestAnimationFrame(step);
        },
        offTranslate: () => {
            cancelAnimationFrame(Attribute.translateRef);
        }
    }


    const enterAnimaCore = {
        play:(e) => {
            const xPercent = e.offsetX / rect.width - 0.5;
            const yPercent = e.offsetY / rect.height - 0.5;
            Attribute.finX = xPercent;
            Attribute.finY = yPercent;
            Attribute.translate();
        }
    }
    
    const moveAnimaCore = {
        play: (e) => {
            const xPercent = e.offsetX / rect.width - 0.5;
            const yPercent = e.offsetY / rect.height - 0.5;
            Attribute.finX = xPercent;
            Attribute.finY = yPercent;
        }
    }


    const leaveAnimaCore = {
        play: () => {
            Attribute.finX = 0;
            Attribute.finY = 0;
            setTimeout(()=>{Attribute.offTranslate()}, 5000);
        }
    }
    return {
        enter: enterAnimaCore,
        move: moveAnimaCore,
        leave: leaveAnimaCore,
    }
}


const circleCursor = (anima) => {
    anima = {
        circleSize: 100,
        circleColor: 255,
        cursor: false,
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }

    const target = document.querySelector(anima.target);
    const target__style = window.getComputedStyle(target,null);
    if (target__style.getPropertyValue('position') === 'static')
        target.style.position = "relative";

    target.style.cursor = anima.cursor ? 'default' : 'none';
    target.style.overflow = 'hidden';
    const circle = document.createElement('div');
    circle.style.position = `absolute`;
    circle.style.pointerEvents = 'none';
    circle.style.width = `${anima.circleSize}px`;
    circle.style.height = `${anima.circleSize}px`;
    circle.style.borderRadius = `${anima.circleSize}px`;
    circle.style.background = `rgb(${anima.circleColor}, ${anima.circleColor}, ${anima.circleColor})`;
    circle.style.mixBlendMode = 'difference';
    circle.style.transform = 'scale(0, 0)';
    target.appendChild(circle);

    const Attribute = {
        x: 0,
        y: 0,
        finX: 0,
        finY: 0,
        scale: 0,
        onMouse: false,
        translateRef: null,
        repaint: () => {
            circle.style.transform = `translate(${Attribute.x}px, ${Attribute.y}px) scale(${Attribute.scale}, ${Attribute.scale})`;
        },
        translate: () => {
            const step = () => {
                Attribute.x = Attribute.x + (Attribute.finX - Attribute.x) * 0.2;
                Attribute.y = Attribute.y + (Attribute.finY - Attribute.y) * 0.2;
                circle.style.transform = `translate(${Attribute.x}px, ${Attribute.y}px) scale(${Attribute.scale}, ${Attribute.scale})`;
                Attribute.translateRef = requestAnimationFrame(step);
            }
            Attribute.translateRef = requestAnimationFrame(step);
        },
        offTranslate: () => {
            cancelAnimationFrame(Attribute.translateRef);
        }
    };


    const enterAnimaCore = new FinAnimaCore();
    enterAnimaCore.setRepeat(true);
    const enterAnima = new FinAnima({
        initFunc: (e) => {
            console.log(e);
            Attribute.translate();
            Attribute.x = e.offsetX - circle.offsetLeft - (anima.circleSize /2);
            Attribute.y =e.offsetY - circle.offsetTop - (anima.circleSize /2);
            circle.style.transform = 'scale(0, 0)';
        },
        func: (progress) => {
            Attribute.scale = progress;
            Attribute.repaint();
        },
        duration: 0.3,
        easingFunction: 'easeInSine',
    })
    enterAnimaCore.addFinAnima(enterAnima)

    const moveAnimaCore = {
        play: (e) => {
            Attribute.finX = e.offsetX - circle.offsetLeft - (anima.circleSize /2);
            Attribute.finY = e.offsetY - circle.offsetTop - (anima.circleSize /2);
        }
    }

    const leaveAnimaCore = new FinAnimaCore();
    leaveAnimaCore.setRepeat(true);

    const leaveAnima = new FinAnima({
        initFunc: (e) => {
            Attribute.offTranslate();
        },
        func: (progress) => {
            Attribute.scale = 1 - progress;
            Attribute.repaint();
        },
        duration: 0.3,
        easingFunction: 'easeOutSine',
        repeat:true,
    })
    leaveAnimaCore.addFinAnima(leaveAnima)


    return {
        enter: enterAnimaCore,
        move: moveAnimaCore,
        leave: leaveAnimaCore,
    }
}

const imageCursor = (anima) => {
    anima = {
        imageWidth: 300,
        imageHeight: 200,
        cursor: true,
        ...anima,
    }

    if (!anima.target) { console.error('target is undefined'); return; }
    if (!anima.imageSrc) { console.error('imageSrc is undefined'); return; }

    const target = document.querySelector(anima.target);
    const target__style = window.getComputedStyle(target,null);
    if (target__style.getPropertyValue('position') === 'static')
        target.style.position = "relative";
    target.style.cursor = anima.cursor ? 'default' : 'none';


    const image = document.createElement('img');
    image.src = anima.imageSrc;
    image.style.position = `absolute`;
    image.style.pointerEvents = 'none';
    image.style.width = `${anima.imageWidth}px`;
    image.style.height = `${anima.imageHeight}px`;
    image.style.transform = 'scale(0, 0)';
    image.style.zIndex = 1;
    target.appendChild(image);


    const Attribute = {
        x: 0,
        y: 0,
        finX: 0,
        finY: 0,
        scale: 0,
        onMouse: false,
        translateRef: null,
        repaint: () => {
            image.style.transform = `translate(${Attribute.x}px, ${Attribute.y}px) scale(${Attribute.scale}, ${Attribute.scale})`;
        },
        translate: () => {
            const step = () => {
                Attribute.x = Attribute.x + (Attribute.finX - Attribute.x) * 0.1;
                Attribute.y = Attribute.y + (Attribute.finY - Attribute.y) * 0.1;
                image.style.transform = `translate(${Attribute.x}px, ${Attribute.y}px) scale(${Attribute.scale}, ${Attribute.scale})`;
                Attribute.translateRef = requestAnimationFrame(step);
            }
            Attribute.translateRef = requestAnimationFrame(step);
        },
        offTranslate: () => {
            cancelAnimationFrame(Attribute.translateRef);
        }
    };


    const enterAnimaCore = new FinAnimaCore();
    enterAnimaCore.setRepeat(true);

    const enterAnima = new FinAnima({
        initFunc: (e) => {
            Attribute.translate();
            Attribute.x = e.offsetX - image.offsetLeft - (anima.imageWidth/2);
            Attribute.y = e.offsetY - image.offsetTop - (anima.imageHeight /2);
            image.style.transform = 'scale(0, 0)';
        },
        func: (progress) => {
            Attribute.scale = progress;
            Attribute.repaint();
        },
        duration: 0.2,
        easingFunction: 'easeInSine',
        repeat:true,
    })
    enterAnimaCore.addFinAnima(enterAnima)

    const moveAnimaCore = {
        play: (e) => {
            Attribute.finX = e.offsetX - image.offsetLeft - (anima.imageWidth/2);
            Attribute.finY = e.offsetY - image.offsetTop - (anima.imageHeight /2);
        }
    }

    const leaveAnimaCore = new FinAnimaCore();
    leaveAnimaCore.setRepeat(true);

    const leaveAnima = new FinAnima({
        initFunc: (e) => {
            Attribute.offTranslate();
        },
        func: (progress) => {
            Attribute.scale = 1 - progress;
            Attribute.repaint();
        },
        duration: 0.3,
        easingFunction: 'easeOutSine',
        repeat:true,
    })
    leaveAnimaCore.addFinAnima(leaveAnima)


    return {
        enter: enterAnimaCore,
        move: moveAnimaCore,
        leave: leaveAnimaCore,
    }
}


const stickyFadeInOut = (anima) => {
    anima = {
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    target.style.position = 'sticky'
    target.style.opacity = 0
    target.style.transform = `translateY(-100%)`;

    const finAnimaCore = new FinAnimaCore();
    const inAnima = new FinAnima({
        func: (progress) => {
            target.style.opacity = progress;
            target.style.transform = `translateY(${100-(progress*100)}%)`;
        },
        duration: 0.1,
        easingFunction: 'easeInSine',
        repeat:true,
    })
    finAnimaCore.addFinAnima(inAnima)

    const outAnima = new FinAnima({
        func: (progress) => {
            target.style.opacity = 1 - progress;
            target.style.transform = `translateY(${-(progress*100)}%)`;
        },
        duration: 0.1,
        timing:0.8,
        easingFunction: 'easeInSine',
        repeat:true,
    })
    finAnimaCore.addFinAnima(outAnima)

    return finAnimaCore
}


const stickyScaleUp = (anima) => {
    anima = {
        appear:'bottom/top',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target);
    target.style.position = 'sticky'
    target.style.opacity = 0
    target.style.transform = `scale(0)`;

    const finAnimaCore = new FinAnimaCore();
    const inAnima = new FinAnima({
        func: (progress) => {
            target.style.opacity = progress;
            target.style.transform = `scale(${progress})`;
        },
        duration: 0.1,
        easingFunction: 'easeInSine',
        repeat:true,
    })
    finAnimaCore.addFinAnima(inAnima)

    const outAnima = new FinAnima({
        func: (progress) => {
            target.style.opacity = 1 - progress;
            target.style.transform = `translateY(${-(progress*100)}%)`;
        },
        duration: 0.1,
        timing:0.8,
        easingFunction: 'easeInSine',
        repeat:true,
    })
    finAnimaCore.addFinAnima(outAnima)

    return finAnimaCore
}


const slide1 = (anima) => {
    /******init*******/
    anima = {
        duration: 0.3,
        easingFunction: 'easeInOutSine',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)
    const wrapper = createWrapper(target);
    wrapper.style.overflow = "hidden";
    target.style.transform = "translateX(-100%)";
    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima = new FinAnima({
        func: (progress) => {

            target.style.transform = `translateX(${-100 + (progress * 100)}%)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)
    return finAnimaCore;
}

const slide2 = (anima) => {
    /******init*******/
    anima = {
        duration: 0.3,
        easingFunction: 'easeInOutSine',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)
    const wrapper = createWrapper(target);
    wrapper.style.overflow = "hidden";
    wrapper.style.transform = "translate(-100%, -100%)";
    target.style.transform = "translate(100%, 100%)";

    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima = new FinAnima({
        func: (progress) => {

            wrapper.style.transform = `translate(${-100 + (progress * 100)}%, ${-100 + (progress * 100)}%)`;
            target.style.transform = `translate(${100 - (progress * 100)}%, ${100 - (progress * 100)}%)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)
    return finAnimaCore;
}


const slide3 = (anima) => {
    /******init*******/
    anima = {
        duration: 0.8,
        easingFunction: 'easeOutExpo',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)
    const wrapper = createWrapper(target);
    wrapper.style.overflow = "hidden";

    wrapper.style.transform = "translate(50%, 120%) rotate(50deg)";
    target.style.transform = "translate(-50%, -120%) rotate(-50deg)";

    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima = new FinAnima({
        func: (progress) => {

            const transX = linearFromTo(progress, 50, 0);
            const transY = linearFromTo(progress, 120, 0);
            const rotate = linearFromTo(progress, 50, 0);
            wrapper.style.transform = `translate(${transX}%, ${transY}%) rotate(${rotate}deg)`;
            target.style.transform = `translate(-${transX}%, -${transY}%) rotate(-${rotate}deg)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)
    return finAnimaCore;
}

const rotate1 = (anima) => {
    /******init*******/
    anima = {
        duration: 1,
        easingFunction: 'easeOutExpo',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)
    const wrapper = createWrapper(target);
    wrapper.style.overflow = "hidden";

    wrapper.style.transform = "scale(0) rotate(90deg)";
    target.style.opacity = 0;

    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima = new FinAnima({
        func: (progress) => {

            const rotate = linearFromTo(progress, 90, 0);
            target.style.opacity = progress;
            wrapper.style.transform = `scale(${progress}) rotate(${rotate}deg)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)
    return finAnimaCore;
}
const throw1 = (anima) => {
    /******init*******/
    anima = {
        duration: 1,
        easingFunction: 'easeOutQuint',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)
    target.style.transformOrigin = "200% 0%";
    target.style.transform = "rotate(-60deg)";
    target.style.opacity = 0;

    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    const finAnima = new FinAnima({
        func: (progress) => {

            const rotate = linearFromTo(progress, -60, 0);
            target.style.opacity = progress;
            target.style.transform = `rotate(${rotate}deg)`;
        },
        duration: anima.duration,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)
    return finAnimaCore;
}

const ghost1 = (anima) => {
    /******init*******/
    anima = {
        duration: 1,
        cutCount: 5,
        gap: 20,
        easingFunction: 'easeOutExpo',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)
    const wrapper = createWrapper(target);
    const cloneImages = [];
    let clone;
    for (let i = anima.cutCount; i >= 1; i--) {
        clone = target.cloneNode(true);
        clone.id = '';
        clone.style.position = "absolute";
        clone.style.transform = `translate(${i * anima.gap}px, ${i * anima.gap}px)`;
        clone.style.opacity = 0;
        wrapper.appendChild(clone);
        cloneImages.push(clone);
    }

    target.style.position = "absolute";
    target.style.transform = `translate(${anima.gap}px, ${anima.gap}px)`;
    target.style.opacity = 0;

    wrapper.removeChild(target);
    wrapper.appendChild(target);


    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    cloneImages.forEach((clone, index) => {
        const finAnima = new FinAnima({
            func: (progress) => {

                if (progress <= 0.5) {
                    clone.style.opacity = progress * 2;
                } else {
                    const opacity = linearFromTo(progress, 2, 0);
                    clone.style.opacity = opacity;
                }
            },
            duration: anima.duration,
            timing: (anima.duration - 0.05) * -1,
            easingFunction: anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })
    const finAnima = new FinAnima({
        func: (progress) => {

            if (progress * 4 > 1) target.style.opacity = 1;
            else target.style.opacity = progress * 4;

            const translate = linearFromTo(progress, anima.gap, 0);
            target.style.transform = `translate(${translate}px, ${translate}px)`;
        },
        duration: anima.duration,
        timing: (anima.duration - 0.05) * -1,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)


    return finAnimaCore;
}

const ghost2 = (anima) => {
    /******init*******/
    anima = {
        duration: 1,
        cutCount: 5,
        gap: 40,
        easingFunction: 'easeOutExpo',
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    const target = document.querySelector(anima.target)
    const wrapper = createWrapper(target);
    const cloneImages = [];
    let clone;
    for (let i = anima.cutCount; i >= 1; i--) {
        clone = target.cloneNode(true);
        clone.id = '';
        clone.originTransform = {
            x: getRandomInt(-10, 11),
            y: getRandomInt(-10, 11),
            rotate: getRandomInt(-10, 11),
        };
        clone.style.position = "absolute";
        clone.style.transform = `translate(${i * anima.gap + clone.originTransform.x}px, ${i * anima.gap + clone.originTransform.y}px) rotate(${clone.originTransform.rotate}deg)`;
        clone.style.opacity = 0;
        wrapper.appendChild(clone);
        cloneImages.push(clone);
    }

    target.style.position = "absolute";
    target.style.transform = `translate(${anima.gap}px, ${anima.gap}px)`;
    target.style.opacity = 0;

    wrapper.removeChild(target);
    wrapper.appendChild(target);


    /******play*******/
    const finAnimaCore = new FinAnimaCore();
    cloneImages.forEach((clone, index) => {
        const finAnima = new FinAnima({
            func: (progress) => {

                if (progress <= 0.5) {
                    clone.style.opacity = progress * 2;
                } else {
                    const opacity = linearFromTo(progress, 2, 0);
                    clone.style.opacity = opacity;
                }
                //clone.style.transform = `translate(${translate}px, ${translate}px)`;

            },
            duration: anima.duration,
            timing: (anima.duration - 0.05) * -1,
            easingFunction: anima.easingFunction,
        })
        finAnimaCore.addFinAnima(finAnima)
    })
    const finAnima = new FinAnima({
        func: (progress) => {

            if (progress * 4 > 1) target.style.opacity = 1;
            else target.style.opacity = progress * 4;

            const translate = linearFromTo(progress, anima.gap, 0);
            target.style.transform = `translate(${translate}px, ${translate}px)`;
        },
        duration: anima.duration,
        timing: (anima.duration - 0.05) * -1,
        easingFunction: anima.easingFunction,
    })
    finAnimaCore.addFinAnima(finAnima)


    return finAnimaCore;
}
const chewing = (anima) => {
    /******init*******/
    anima = {
        duration: 1.3,
        easingFunction: 'easeOutExpo',
        ...anima,
    }
    if (!anima.target) console.error('target is undefined');
    const target = document.querySelector(anima.target)

    let transX = 100;
    let transY = 5;
    let scaleX = 0.5;
    let scaleY = 1;
    let rotate = 10;
    target.style.transformOrigin = "95% 50%";
    target.style.transform = `translate(${transX}%, ${transY}%) scale(${scaleX}, ${scaleY}) rotate(${rotate}deg)`;
    target.style.opacity = 0;

    /******play*******/
    const finAnimaCore = new FinAnimaCore();

    const finAnima = new FinAnima({
        func: (progress) => {

            scaleX = linearFromTo(progress, 0.5, 1.3);
            scaleY = linearFromTo(progress, 1, 0.7);
            target.style.transform = `translate(${transX}%, ${transY}%) scale(${scaleX}, ${scaleY}) rotate(${rotate}deg)`;
        },
        duration: anima.duration * 0.2,
        easingFunction: anima.easingFunction,
    })

    const finAnima2 = new FinAnima({
        func: (progress) => {

            rotate = linearFromTo(progress, 10, 0);
            transY = linearFromTo(progress, 5, 0);
            target.style.opacity = progress;
            target.style.transform = `translate(${transX}%, ${transY}%) scale(${scaleX}, ${scaleY}) rotate(${rotate}deg)`;
        },
        duration: anima.duration * 0.8,
        timing: -(anima.duration * 0.2),
        easingFunction: anima.easingFunction,
    })

    const finAnima3 = new FinAnima({
        func: (progress) => {
            target.style.transformOrigin = "0% 50%";
            scaleX = linearFromTo(progress, 1.3, 1);
            scaleY = linearFromTo(progress, 0.7, 1);
            transX = linearFromTo(progress, 100, 0);
            target.style.transform = `translate(${transX}%, ${transY}%) scale(${scaleX}, ${scaleY}) rotate(${rotate}deg)`;
        },
        duration: anima.duration * 0.6,
        timing: anima.duration * -0.6,
        easingFunction: anima.easingFunction,
    })

    finAnimaCore.addFinAnima(finAnima)
    finAnimaCore.addFinAnima(finAnima2)
    finAnimaCore.addFinAnima(finAnima3)


    return finAnimaCore;
}


const playCanvasVideo = (anima) => {
    anima = {
        ...anima,
    }
    if (!anima.target) { console.error('target is undefined'); return; }
    if (!anima.images) { console.error('images is undefined'); return; }

    const target = document.querySelector(anima.target);
    target.style.position = 'sticky';
    target.width = window.innerWidth;
    target.height = window.innerHeight;
    const ctx = target.getContext('2d');
    const images = [];
    let image;
    for(let i=0;i<anima.images.count; i++){
        image = new Image();
        image.src = anima.images.path + anima.images.filename + String(i).padStart(3, '0') + '.' + anima.images.extension
        images.push(image)
    }
    images[0].addEventListener('load', e => {
        ctx.drawImage(images[0], 0, 0)
    })
    
    const finAnimaCore = new FinAnimaCore();
    const inAnima = new FinAnima({
        func: (progress) => {
            const index = Math.floor(progress*anima.images.count);
            ctx.drawImage(images[index], 0, 0)
            console.log(window.scrollY)
        },
        duration: 1,
        easingFunction: 'easeInSine',
        repeat:true,
    })
    finAnimaCore.addFinAnima(inAnima)


    return finAnimaCore
    
}


